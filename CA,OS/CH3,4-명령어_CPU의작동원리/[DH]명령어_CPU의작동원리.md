# Chapter 03 - 명령어
## 03-1 소스 코드와 명령어
### 고급 언어와 저급 언어
- 고급 언어: 사람이 이해하고 작성하기 쉽게 만들어진 언어(high-level programming language)
- 저급 언어: 컴퓨터가 직접 이해하고 실행할 수 있는 언어(low-level programming language)
- 고급 언어로 작성된 소스 코드가 실행되려면 반드시 저급 언어(명령어)로 변환되어야 함

- 기계어: 0, 1의 명령어 비트로 이루어진 언어
  - 기계어가 무엇을 의미하고, 어떻게 작동시키는 것인지 알기 어려움
- 어셈블리어: 기계어를 읽기 편한 형태로 번역한 언어(저급 언어)
  - 어셈블리어를 읽으면 컴퓨터가 프로그램을 어떤 과정으로 실행하는지를 하나하나 추적 및 관찰 가능

### 컴파일 언어와 인터프리터 언어
- 컴파일 언어: 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어(ex - C)
  - 컴파일: 소스 코드 전체가 저급 언어로 변환되는 과정(compile)
  - 컴파일러: 컴파일을 수행하는 도구
    - 소스 코드를 확인하며 문법 오류는 없는지, 실행 가능한지 등을 판단하며 저급 언어로 컴파일
  - 목적 코드: 컴파일러를 토해 저급 언어로 변환된 코드(object code)

- 인터프리터 언어: 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어(ex - python)
  - 소스 코드를 한 줄씩 차례로 실행
  - 인터프리터: 소스 코드를 한 줄씩 저급 언어로 변환하여 실행해 주는 도구
    - 한 줄씩 실행하므로 소스 코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요가 없음
    - N번째 줄에 문법 오류가 있더라도 N-1번째 줄까지는 올바르게 수행됨
    - 소스 코드 마지막에 이를 때까지 한 줄씩 저급 언어로 해석하며 실행해야 하기 때문에 컴파일 언어보다 느림

- 컴파일 언어와 인터프리터 언어는 명확히 구분되지 않는 경우가 많음
  - 두 가지를 같이 사용하기 때문(python, Java, ..)
  - 컴파일 언어라도 인터프리트가 가능하며, 인터프리터 언어라도 컴파일이 가능

### 목적 파일 vs 실행 파일
- 목적 파일: Object code로 이루어진 파일
- 실행 파일: 실행 코드로 이루어진 파일(ex - .exe)
- 목적 코드가 실행 파일이 되기 위해선 **링킹** 이라는 작업을 거쳐야 함
- 링킹: 파일 간 연결 작업. 서로 다른 파일이 유기적으로 연결되어 구현된 프로젝트를 하나의 실행파일로 만드는 과정

## 03-2 명령어와 구조
### 연산 코드와 오퍼랜드
- 명령어는 연산 코드와 오퍼랜드로 구성되어 있음
  - 연산 코드: operation code. 명령어가 수행할 연산(연산자)
  - 오퍼랜드: 연산에 사용할 데이터 or 데이터의 위치(피연산자)

### 오퍼랜드
- 오퍼랜드 필드엔 데이터 or 메모리, 레지스터 주소가 올 수 있음
  - 주로 주소 정보가 담기기에 **주소 필드** 라고 불림
  - 명령어 안에 없을 수도 있으며, 여러 개가 있을 수도 있음
    - 오퍼랜드가 없는 명령어: 0-주소 명령어
    - 오퍼랜드가 1개인 명령어: 1-주소 명령어
    - 오퍼랜드가 2개인 명령어: 2-주소 명령어
    - 오퍼랜드가 3개인 명령어: 3-주소 명령어

### 연산 코드
- 가장 기본적으로 네 가지로 구분 가능
  - 데이터 전송(MOVE, STORE, LOAD, ..)
  - 산술/논리 연산(ADD, SUBTRACT, MULTIPLY, AND, OR, NOT, ...)
  - 제어 흐름 변경(JUMP, CONDITIONAL JUMP, CALL, ...)
  - 입출력 제어(READ, WRITE, START IO, ...)

### 주소 지정 방식
- 명령어의 양에 비해 오퍼랜드 필드가 작기 때문에 주로 주소를 담는 것
- 유효 주소: 연산 코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치(effective address)
- 주소 지정 방식: 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법
  - 즉시 주소 지정 방식: 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
  - 직접 주소 지정 방식: 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
  - 간접 주소 지정 방식: 유효 주소의 주소를 오퍼랜드 필드에 명시
  - 레지스터 주소 지정 방식: 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법
  - 레지스터 간접 주소 지정 방식: 연산에 사용할 데이터를 메모리에 저장하고, 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시


# 04. CPU의 작동 원리
## 04-1 ALU와 제어장치
### ALU
- ALU: 계산하는 부품
- 레지스터를 통해 피연산자를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 제어 신호를 받음
- 연산 수행 후, 결괏값은 메모리가 아닌 일시적으로 레지스터에 저장됨(메모리 접근이 오래 걸리므로)
- 계산 결과와 더불어 플래그를 내보냄. 이 값은 플래그 레지스터에 저장됨
  - 부호 플래그(연산 결과의 부호)
  - 제로 플래그(연산 결과가 0인지)
  - 캐리 플래그(연산 결과 올림수나 빌림수가 발생했는지)
  - 오버플로우 플래그(오버플로우가 발생했는지)
  - 인터럽트 플래그(인터럽트가 가능한지)
  - 슈퍼바이저 플래그(커널 모드로 실행 중인지)

### 제어장치
- 제어 신호를 내보내고, 명령어를 해석하는 부품
- 제어 신호: 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호
- 제어장치가 받아들이는 정보
  - 클럭(clock) 신호: 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위
  - 해석해야 할 명령어: CPU가 해석해야 할 명령어는 **명령어 레지스터**에 저장됨. 
    - 제어장치는 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 두, 제어 신호를 발생시켜 컴퓨터 부품들이 수행해야 할 내용을 알려줌
  - 플레그 값: 플래그 레지스터에서 플래그 값을 받아들이고 이를 참고해 제어 신호를 발생시킴
  - 제어 신호: 외부 장치에서 발생한 제어 신호를 제어 버스로 전달받음

- 제어장치가 내보내는 정보
  - CPU 외부에 전달하는 제어 신호: 제어 버스로 제어 신호를 내보낸다는 것
  - CPU 내부에 전달하는 제어 신호: ALU에 전달하는 제어 신호, 레지스터에 전달하는 제어 신호

## 04-2 레지스터
### 반드시 알아야 할 레지스터
- 프로그램 카운터: PC. 메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어 들일 명령어의 주소를 저장
- 명령어 레지스터: IR(Instruction Register). 해석할 명령어, 즉 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터
- 메모리 주소 레지스터: MAR(Memory Address Register). 메모리의 주소를 저장하는 레지스터
- 메모리 버퍼 레지스터: MBR(Memory Buffer Register). 메모리와 주고받을 값을 저장하는 레지스터
- 플래그 레지스터: (Flag Register). 연산 결과 또는 CPU 상태에 대한 부가적인 정보 저장
- 범용 레지스터: (General Purpose Register). 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터. CPU 안에너느 여러 개의 범용 레지스터들이 있음
- 스택 포인터: 스택 주소 지정 방식에 사용됨
- 베이스 레지스터: 변위 주소 지정 방식에 사용됨 

### 특정 레지스터를 이용한 주소 지정 방식(1): 스택 주소 지정 방식
- 스택과 스택 포인터를 이용한 주소 지정 방식
  - 스택 포인터: 스택의 꼭대기

### 특정 레지스터를 이용한 주소 지정 방식(2): 변위 주소 지정 방식
- 변위 주소 지정 방식: 오퍼랜드 필드 값과 특정 레지스터의 값을 더해 유효 주소를 얻어내는 주소 지정 방식

## 04-3 명령어 사이클과 인터럽트
- 명령어 사이클: 하나의 명령어를 처리하는 정형화된 흐름
- 인터럽트: 흐름이 끊어지는 상황

### 명령어 사이클
- 프로그램 속 각 명령어가 일정한 주기로 반복되며 실행되는 것
  - 인출 사이클(메모리에 있는 명령어를 CPU로 가지고 오는 단계)
  - 실행 사이클(CPU로 가지고 온 명령어를 실행하는 단계)
  - 간접 사이클: 간접 주소 지정 방식의 경우 메모리 접근을 한 번 더 해야 할 때의 사이클

### 인터럽트
- interrupt: 방해하다, 중단시키다
- CPU의 작업을 방해하는 신호
- 동기 인터럽트: CPU에 의해 발생하는 인터럽트. 
  - CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 떄 발생하는 인터럽트(exception)
- 비동기 인터럽트: 주로 IO장치에 의해 발생하는 인터럽트. 주로 인터럽트라고 말하면 비동기 인터럽트를 의미함.
- 인터럽트 처리 순서
  - IO는 CPU에 인터럽트 요청 신호를 보냄
  - CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트를 확인함
  - CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인함
    - 플래그에 따라 처리 유무를 결정하는데, 플래그로 막을 수 없는 인터럽트도 있음(HW 고장 등)
  - 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업함
    - PC 등 프로그램 재개를 위해 필요한 모든 내용을 스택에 백엄
  - CPU는 인터럽트 벡터를 참조해 인터럽트 서비스 루틴을 실행함
    - 인터럽트 서비스 루틴을 식별하기 위한 정보
  - 인터럽트 서비스 루틴 실행이 끝나면 백업해 둔 작업을 복구해 실행을 재개함

### 예외의 종류
- 예외: 예외가 발생하면 CPU는 하던 일을 중단하고 예외를 처리함. 처리 후 본래 작업으로 되돌아와 실행을 재개
- 폴트: 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외
- 트랩: 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외(주로 디버깅할 때 사용)
- 중단: CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류를 발견했을 때 발생하는 예외