# Chapter 14. 가상 메모리
## 14-1 연속 메모리 할당
### 스와핑
- 대기 상태 or 오래 사용하지 않은 프로세스를 보조 기억장치 스왑 영역 으로 옮기고, 메모리 빈 공간을 다른 프로세스에 할당해 실행하는 방식
  - 스왑 아웃: 프로세스가 스왑 영역으로 옮겨지는 것
  - 스왑 인: 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것
  - 스압 아웃된 프로세스가 다시 스왑 인 될 때는 이전과 다른 주소에 적재될 수 있다.
    
### 메모리 할당
- 프로세스는 메모리의 빈 공간에 적재되어야 한다. 적재 방식은 대표적으로 3 가지 방법 있다.
  - 최초 적합: OS가 메모리 내 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 배치
    - 검색 최소화, 결과적으로 빠른 할당 가능
  - 최적 적합: OS가 QLS 빈 공간을 모두 확인한 후 적재될 수 있는 공간 중 가장 작은 공간에 프로세스 배치 
  - 최악 적합: 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 배치

### 외부 단편화
- 프로세스 바깥에 생기는 메모리 빈 공간이 낭비되는 현상
- 압축: 외부 단편화를 해결할 수 있는 대표적인 방안(= 메모리 조각 모음)
  - 흩어져 있는 빈 공간들을 하나로 모으는 방식
  - 단점: 작은 빈 공간을 하나로 모으는 동안 시스템은 하던 일을 중지해야 하며, 과정에서 많은 오버헤드를 야기
  - 따라서 현재는 페이징 기법을 사용

## 14-2 페이징을 통한 가상 메모리 관리
- 가상 메로리: 실행하고자 하는 프로그램을 일부만 메모리에 적재해 실제 물리 메모리 크기보다 더 큰 메모리를 실행할 수 있게 하는 기술
- 페이징, 세그멘테이션 기법이 있음

### 페이징이란
- 메모리와 프로세스를 일정한 단위(페이지)로 자르고, 이를 메모리에 불연속적으로 할당할 수 있게 하는 것.
  - 메모리의 물리 주소 공간을 프레임 단위로 자르고, 프로세스의 논리 주소 공간을 페이지 단위로 자른 뒤 각 페이지를 프레임에 할당하는 가상 메모리 관리 기법
- 메모리에 적재될 필요 없는 페이지는 보조기억장치로 스왑 아웃(페이지 아웃), 필요하면 스왑 인(페이지 인)

### 페이지 테이블
- 프로세스가 불연속적으로 메모리에 배치되면, CPU입장에선 순차적으로 실행할 수 없다.
- 이를 해결하기 위해 페이징 시스템은 페이지 테이블을 이용
- 프로세스마다 페이지 테이블을 가지며, 페이지 테이블은 메모리에 적재된다. CPU 내의 페이지 테이블 베이스 레지스터(PTBR)가 각 프로세스의 페이지 테이블이 적재된 주소를 가리킴
- 페이지 테이블을 사용하면, 실제 값에 접근하기 위해 과정을 2번 거쳐야 함. 이를 해결하기 위해 CPU 곁에 TLB(Translation Lookaside Buffer)라는 페이지 테이블의 캐시 메모리를 툼
- 캐시이므로 일부 내용만 저장
  - 사용하고자 하는 페이지 번호가 TLB에 있으면 TLB 히트
  - 페이지 번호가 없으면 TLB 미스 라고 함

### 페이징에서의 주소 변환
- 페이징 시스템에서 특정 주소에 접근하려면 '어떤 페이지 인가(페이지 번호)'와 '접근하려는 주소가 페이지로부터 얼마나 떨어져 있는가(변위)'에 대한 정보가 필요

### 페이지 테이블 엔트리
- 페이지 테이블의 각 행을 지칭
- 유효 비트: 현재 해당 페이지에 접근 가능한지 여부를 알려주는 비트(페이지 테이블 엔트리에서 프레임 번호 다음으로 중요하다고 볼 수 있음)
  - 스와핑이 발생해 현재 페이지가 메모리에 적재되지 않은 상황인 경우에 대한 판단을 할 수 있는 비트. (적재되어 있으면 1, 없으면 0)
    - 유효비트가 0인 페이지에 접근하려는 경우 페이지 폴트(Page Fault) 발생
- 보호 비트: 페이지 보호 기능을 위해 존재하는 비트(1이면 RW, 0이면 R 권한, 코드 영역인 경우 읽기 전용 영역이므로 0)
  - r, w, x(실행) 으로 구분해 보다 고차원적으로 만들 수 있음
- 참조 비트: CPU가 해당 페이지에 접근한 적이 있는지 여부를 나타내는 비트(있으면 1, 없으면 0)
- 수정 비트: 해당 페이지에 데이터를 쓴 적이 있는지 수정 여부를 나타내는 비트(= 더티 비트, 1이면 변경된 적이 있는 것)
  - 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야하는지, 하지 않아도 되는지 판단하기 위해 존재
  - 수정 비트가 0이면 수정된 적이 없는 것이므로 쓰기 작업이 필요 없음

### 페이지 테이블 방식의 다른 장점
- 외부 단편화 해결 외에 '쓰기 시 복사' 장점이 있다.
- 자식 프로세스를 생성할 때, 동일한 페이지를 모두 복사하지 않고, 쓰기 작업이 이루어져 분기해야 할 때 페이지를 복사

## 14-3 페이지 교체와 프레임 할당
### 요구 페이징
- 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 적재하는 기법 
- 순수 요구 페이징: 아무런 페이지도 메모리에 적재하지 않은 채 무작정 실행하는 방법. 페이지 폴트가 계속 발생하다가 점차 빈도가 떨어짐
- 요구 페이징 기법으로 페이지를 적재하면 언젠가 모든 프레임이 가득 찬다. 이 경우, 스와핑을 수행해야 한다.

### 페이지 교체 알고리즘
- FIFO 페이지 교체 알고리즘
  - 가장 먼저 올라온 페이지부터 스와핑하는 방식.
  - 구현이 간단하지만 성능은 다른 알고리즘에 비해 낮다.
- 2차 기회 페이지 교체 알고리즘
  - FIFO의 변형. 한 번 더 기회를 준다. 참조 비트가 1이면 0으로 변경 후 넘어가고, 0이면 스와핑 수행
- 최적 페이지 교체 알고리즘
  - 앞으로 사용 빈도가 낮은 페이지를 교체하는 방식
  - 현실적으로 앞으로 사용될 예정인 페이지를 알기엔 무리가 있다. 해당 알고리즘은 이론적으로 페이지 
- LRU 페이지 교체 알고리즘
  - 가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘

### 스래싱과 프레임 할당
- 스래싱: 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제
- 멀티프로그래밍의 정도: 메모리에서 동시 실행되는 프로세스의 수
- 프레임 할당 방식:
  - 균등 할당: 총 300개의 프레임을 할당할 수 있다면 각 프로세스에 100개의 프레임을 할당하는 방식
  - 비례 할당: 프로세스의 크기가 크면 프레임을 많이 할당하고 프로세스 크기가 작으면 프레임을 적게 나눠주는 방식
  - 작업 집합 모델: ‘프로세스가 일정 기간 동안 참조한 페이지 집합’을 기억하여 빈번한 페이지 교체를 방지
  - 페이지 폴트 빈도: 아래 두 가정에서 생겨난 아이디어로, 페이지 폴트율에 따라 프로세스에 할당하는 프레임을 설정 
    - 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 갖고 있다. - 프레임을 늘림
    - 페이지 폴트율이 너무 낮으면 그 프로세스가 너무 많은 프레임을 갖고 있다. - 프레임을 줄임