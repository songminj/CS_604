# CH5 응용계층 

## 5-1 DNS와 자원 

서버-클라이언트 통신을 할 때는 메시지를 주고받는 대상을 파악하기 위해 IP주소 이위에 도메인 네임을 사용할 수 있다. 위치기반의 식별자인 URL과 이름 기반의 URN이 있다. 

<br>

### 도메인 네임과 네임 서버 

어떤 호스트를 특정하기 위해 IP주소를 사용하는데 통신하고자 하는 모든 호스트의 IP주소를 기억하고 있는 것은 어렵다. 그래서 IP주소보다는 도메인 네임을 많이 사용한다. 우리가 아는 www.naver.com이 있다. 

<br>

IP주소를 전화번호에 비유하면 도메인 네임은 전화번호에 대응하는 사용자 이름과 같다. 도메인 네임 : IP주소로 네임 서버에서 관리하는데 이것을 DNS서버라고도 한다. 

<br>


### www.google.com 을 알아보자 

- 도메인 네임은 점을 기준으로 계층적으로 분류된다. 최상단에 루트 도메인이 있고 그 다음단계인 최상위 도메인(TLD)이 있다. .com이 최상위 도메인이다. com, net, org, kr, cn, us등이 있다. 일반적으로 루트 도메인이 (.) 인데 마지막 점은 생략하기 때문에 보통은 최상위 도메인만 보인다. 
- 2단계 도메인은 google이다. 
- 3단계 도메인은 www이다. 호스트네임이라고도 한다. 
- 일반적으로 도메인은 3~5단계로 되어있다. www.google.com. 처럼 도메인 네임을 모두 포함하는 도메인네임을 전체주소 도메인네임(FQDN)이라고 한다. 
- DNS란 계층적이고 분산된 도메인 네임의 관리 시스템을 의미한다. 호스트가 이런 도메인 네임 시스템을 이용할 수 있도록 하는 애플리케이션 계층 프로토콜을 의미하기도 한다. 

<br>

### 계층적 네임 서버 

- 도메인 네임을 풀이한다 = 리졸빙 
  - 계층적 네임 서버들을 토대로 도메인이름을 통해 IP주소를 알아내는 과정을 의미한다. 

<br>

- 로컬네임서버 
  - 클라이언트와 맞닿아있는 네임 서버로 클라이언트가 도메인 네임을 통해 IP주소를 알아내고자 할때 가장 먼저 찾게 되는 네임 서버이다.
  - ISP에서 할장해주는 서버를 쓸 수도 있고 DNS서버를 사용할 수 도 있다. 
  - 로컬 네임서버가 특정 도메인 네임에 대응되는 IP주소를 알려주면 되는데 만약 모른다면 루트 네임 서버에게 질의를 하게 된다. 

<br>

- 루트네임서버
  - 루트 도메인을 관장한다. 질의를 받고 TLD네임 서버의 IP주소를 반환할 수 있다. 
<br>

- TLD(최상위도메인) 네임 서버 
  - TLD를 관리하는 네임 서버이다. 얘도 모르면 더 아래의 하위 도메인 네임을 관리하는 데다가 물어보게 된다. 
<br>

- 책임 네임 서버 
  - 특정 도메인 영역을 관리하는 네임 서버이다. 자신이 관리하는 도메인 영역의 질의에 대해서는 다른 네임 서버에게 떠넘기지 않고 바로 말한다. 
<br>

- 재귀적 질의 
  - 클라이언트가 로컬 네임 서버에게 도메인 네임을 질의하면 차례대로 다음 단계 서버에 질의를 하는 과정을 반복하고 응답 결과를 역순으로 전달받는 방식
- 반복적 질의 
  - 클라이언트가 로컬 네임 서버에게 IP주소를 알고싶은 도메인 네임을 질의한다. 로컬 네임서버에서 차례대로 그 하위 서버로 넘어가는것이 아니라 로컬네임서버가 순차적으로 질의를 한 후 최종 응답 결과를 클라이언트에게 알려준다. 


### 너무 오래걸린다 => DNS캐시를 활용

- 도메인 네임을 리졸빙하는데 8개의 단계를 거치는 것처럼 보임. (너무오래걸려요)
- 기존에 응답받은 결과를 임시로 저장해두고, 같은 질의를 할 때 캐시에 저장한 값을 불러온다. 
- 임시 저장된 값은 TTL이라는 값과 함께 저장되는데 캐시될 수 있는 시간을 뜻한다. 

### 자원을 식별하는 URI

- 자원이란?
  - 네트워크상의 메시지를 주고받는 대상을 의미한다 
  - HTML, 이미지, 동영상, 텍스트 등... 
- URI란?
  - 자원을 식별할 수 있는 정보이다. (Uniform Resource Identifier)
- URL?
  - URI의 종류 
  - scheme://authority/path?query#fragment
  - scheme: 자원에 접근하는 방법 (http, https)
  - authority: 호스트를 특정할 수 있는 정보를 의미한다. IP주소, 도메인 네임등이 있다. 
  - path: 자원이 위치한 경로이다. 슬래시를 기준으로 계층적으로 표현된다. 
  - query: 특정 정보를 필요로 할 때 사용한다. key=값 형태의 데이터를 사용하며 &(앰퍼샌드)를 사용하여 여러개의 쿼리 문자열을 연결할 수 있다. 
  - fragment: 자원의 한 조각을 가리키기 위한 정보이다. 
<br>

- URN?
  - 자원에 고유한 이름을 붙이는 방식이다. 
  - urn:ietf:rfc:2648 이런식으로 위치나 프로토콜과 무관하게 자원의 이름으로 식별을 하게 된다. 


<br>


## 5-2 HTTP

### HTTP 의 특성 

1. 요청-응답을 기반으로 동작한다 
   - 클라이언트-서버 구조 기반의 요청-응답 프로토콜이다. 
   - NETWORK 까보면 header와 응답메시지 헤더더를 볼 수 있다. 

2. 미디어 독립적이다 
   - HTTP를 통해 HTML, JPEG, PNG, JSON등을 주고받을 수 있다. 
   - 이런 자원의 종류를 미디어타입이라고 한다. 
   - type/subtype;parameter=value 형식이다. 
   - type/html;charset=UTF-8은 미디어타입이 HTML문서 타입이고 이 안에 사용된 문자는 UTF-8로 인코딩 되어있음을 의미한다. 

3. 상태를 유지하지 않는다 
   - 서버가 HTTP요청을 보낸 클라이언트와 관련된 상태를 기억하지 않는다는 의미이다. 
   - 만약 상태를 유지하는 프로토콜이라면 클라이언트는 자신의 상태를 기억하는 서버하고만 상호작용하게 되어 특정 서버에 종속될 수 있다. 
   - 확장성과 견고성을 위해 모든 요청을 독립적으로 처리하도록 한다. 

4. 지속 연결을 지원한다. 
   - HTTP는 TCP상에서 동작한다. HTTP는 비연결형 프로토콜이지만 TCP는 연결형 프로토콜이다. 따라서 초기의 HTTP버전은 3-way 핸드셰이크를 통해 TCP연결을 수립한 후 요청에 대한 응답을 받으면 연결을 종료하는 식으로 동작했다. 이걸 비지속 방식이라고 한다 
   - 하지만 HTTP버전 1.1 이상은 지속연결이라는 기술을 제공한다. Keep Alive. 더 빠르게 요청-응답 을 받을 수 있다는 장점이 있다. 


### HTTP 메시지 구조

```plain 

시작라인(줄바꿈)
필드라인(줄바꿈)
(줄바꿈)
메시지 본문

```


1. 시작 라인 
   - HTTP요청 메시지일 경우 요청 라인이되고 응답 메시지일 경우 상태 라인이 된다. 
   - 요청의 형식은 다음과 같다 
     - `메서드  요청 대상  HTTP버전\n`
     - 메서드 : 작업의 수행 종류이다. GET, POST, PUT, DELETE
     - 요청 대상 : HTTP요청을 보낼 서버이 자원을 의미한다. 
     - HTTP버전 : 버전을 묻는것  HTTP/<버전> 형태로 표기한다. 
   - 상태라인은 다음과 같다 
     - `HTTP버전  상태코드  이유구문(선택적)`
     - HTTP/1.1 200 OK

<br>

2. 필드라인
   - 0개 이상의 HTTP헤더가 명시된다. 이를 헤더라인이라고 부른다. 

<br>

3. 메시지 본문
   - 분문이 필요한경우 여기에 명시된다. 
   - 존재하지 않을 수도 있고 HTML, JSON등 다양한 콘텐츠 타입이 사용될 수 있다. 


<br>

### HTTP 메서드 

- GET : 특정 자원을 조회할 때 사용한다. 
- HEAD : GET이랑 비슷한데, 메시지 본문이 오지 않는다. 
- POST : 서버에 특정 작업을 요청하는 메서드이다. 
- PUT : 요청 자원이 없다면 메시지 본문으로 자원을 생성하거나 이미 자원이 존재하면 메시지 본문으로 대체한다. 
- PATCH : 일부만 수정한다. 
- DELETE : 삭제한다. 

<br>

### HTTP상태 코드 

- 100번대 : 정보성 상태 코드 
- 200번대 : 성공 상태 코드 
  - 200: OK, 요청이 성공했음 
  - 201: CREATE, 요청이 성공했으며, 새로운 자원이 생성됨
  - 202: ACCEPTED, 요청을 잘 받았으나 아직 요청한 작업을 끝내지 않았음. (대용량 파일 업로드, 배치 작업과 같은 것들..)
  - 204: No Concept. 요청이 성공했지만, 메시지 본문으로 표시할 데이터가 없음.
- 300번대 : 리다이렉션 상태 코드 
  - 301: Moved Permanetly. 재요청 메서드 변경될 수 있음
  - 308: Permanent Redirect. 재요청 메서드가 변경되지 않음
- 400번대 : 클라이언트 에러 상태 코드 
  - 400: bad Request, 클라이언트의 요청이 잘못됨
  - 401: Unauthorized, 요청한 자원에 대한 유효한 인증이 없음
  - 403: Forbidden, 요청이 서버에 의해 거부됨 
  - 404: Not Found, 요청받은 자원을 찾을 수 없음 
  - 405: Method Not Allowed, 요청한 메서드를 지원하지 않음. 
- 500번대 : 서버 에러 상태 코드 
  - 500: Internal Server Error, 요청을 처리할 수 없음
  - 502: Bad Gateway, 중간 서버의 통신 오류 
  - 503: Service Unavailable, 현재는 요청을 처리할 수 없으나 추후 가능할 수도 있음 

<br>



## 5-3 HTTP 헤더와 HTTP 기반 기술 

HTTP메시지의 두번째인 필드라인에는 다양한 HTTP헤더가 명시된다. 

<br>

### HTTP 헤더 

- HTTP 요청 시 활용되는 HTTP헤더 
  - HOST : 요청을 보낼 호스트를 나타내는 헤더이다. 주로 도메인 네임으로 명시되며, 포트 번호가 포함되어 있을 수 있다. 
  - User-Agent : Host 헤더와 더불어 HTTP요청 메시지에서 가장 흔히 볼수 있는 헤더 중 하나이다. 운영체제, 브라우저 종류 및 버전, 렌더링 엔진과 같은 다양한 정보가 User-Agent 헤더에 포함되어 있다. 서버 입장에서는 User-Agent헤더를 통해 클라이언트의 접속 환경을 유추할 수 있다. 
  - Referer : 클라이언트가 요청을 보낼 때 머무르고 있던 URL이 명시된다. 따라서 클라이언트의 유입 경로를 파악해볼 수 있다. 
  - Authorization : 클라이언트의 인증 정보를 담는 헤더이다. 

<br>

- HTTP응답 시 활용되는 HTTP헤더 
  - Server : 요청을 처리하는 서버 측의 소프트웨어와 관련된 정보를 명시한다. 
  - Allow : 405 상태를 응답하는 메시지에 Allow 헤더가 사용된다. 클라이언트에게 허용된 HTTP메서드를 알려준다. 
  - Retry-After:503 상태를 응답하는 메시지에 사용된다. 자원을 사용할 수 있는 날짜나 시각을 알려준다. 
  - Location : 자원의 위치를 알려주기 위해 사용되며 주로 리다이렉션이 발생했을 때나 새로운 자원이 생성되었을 때 사용된다. 
  - WWW-Authenticate : 401일때 응답하는 헤더에 같이 온다. 어떤 인증방식이 필요한지 설명해주는 헤더이다. 

<br>

- 요청과 응답 모두에서 활용되는 HTTP헤더 
  - Date : 메시지가 생성된 날짜와 시각에 관련된 정보가 들어가있따 
  - Connection : 클라이언트의 요청과 응답 간의 연결 방식을 설정하는 헤더이다. 
  - Content-Length : 헤더는 본문의 바이트 단위 크기를 나타낸다. 
  - Content-Type : 메시지 본무의 표현 방식을 설명하는 헤더이다. 

### 캐시 

- 클라이언트가 같은 이미지를 여러번 요청하면 이전에 받았던 응답 사본을 임시로 저장해둔 것을 보여준다. 
- 캐시란 정보의 사본을 임시로 저장하는 기술이며, 불필요한 대역폭 낭비와 응답 지연을 방지하기 위해 사용된다. 
- 원본이 아니라 사본이 저장된다는 점을 주의해야한다. 

### 캐시의 신선도 

- 캐시된 데이터에 유효기간을 설정할 수 있다. 
- 응답 메시지의 Expires 헤더와 Cache-Control헤더의 Max-Age값을 사용할 수 있다. 
  - 캐시의 신선도를 검사하는 방법은 두가지이다. 
  - 날짜를 기반으로 서버에게 물어보는 방법 : If-Modified-Since헤더를 통해 서버에게 특정 시점 이후로 원본 데이터에 변경이 있었는지 물어볼 수 있다. 변경이 있었으면 새 자원으로 응답하도록 요청하는 헤더이다. 
  - 엔티티 태그를 기반으로 서버에게 물어보는 방법 : 자원의 버전을 식별하기 위한 정보인 Etag를 사용한다. If-None-Match 헤더를 사용해서 자원의 엔티티 태그가 바뀌었는지를 확인한다. 

<br>

### 쿠키 

- 서버에 생성되어 클라이언트 측에 저장되는 데이터이다. HTTP의 상태를 유지하지 않는 특성을 보완하기 위한 수단이다. 
- <이름, 값>쌍의 형태를 띠고 있고, 적용범위와 만료 기간등 다양한 속성을 가진다. 
- 로그인 상태를 유지하는지를 확인할 수 있다. 
- 쿠키는 보안에 취약하다. 따라서 민감한 정보를 담아 송수신하는것은 바람직하지 않다.
  - HTTPOnly라는 속성과 Secure로 이를 보완할 수 있다. 
  - HttpOnly : 자바스크립트에서 쿠키에 접근하지 못하도록 하는 속성이다. 

### 콘텐츠 협상과 표현 

콘텐츠 협상이란?
- 같은 URI에 대해 가장 적합한 자원의형태를 제공하는 메커니즘을 의미한다. 같은 URI로 식별가능한 문서라고 해도, 영어로 요청하면 영어로, 한국어로 요청하면 한국어로 된 것을 제공한다. 
- 송수신 가능한 자원의 형태를 자원의 표현이라고 한다. 


## 오늘의 면접 질문 


1. 주소창에 www.naver.com을 입력했을 때 발생하는 일을 순서대로 말해주세요 (Http, Dns, Tcp, 서버, 클라이언트 etc...)

A. 웹 브라우저에 URL을 입력했을 때 요청이 처리되는 단계를 설명하겠습니다. 
1. 사용자가 www.naver.com을 주소창에 입력하고 엔터를 누릅니다
2. 도메인을 IP주소로 변환하기 위해 DNS조회를 시작합니다. 
3. 조회된 IP주소를 통해 서버와 TCP연결을 설정합니다. (3-way 핸드셰이크)
4. 브라우저는 서버로 HTTP/HTTPS요청을 보냅니다. 
5. 서버는 요청을 수신한 후 리소스를 처리합니다. 
6. 서버가 처리 결과를 상태코드와 콘텐츠를 포함하여 HTTP응답으로 반환힙니다. 
7. 브라우저는 수신한 HTML, CSS, JS를 처리하여 웹 페이지를 렌더링합니다. 

[좀 더 구체적인 설명](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Network/%EC%A3%BC%EC%86%8C%EC%B0%BD%EC%97%90%20naver.com%EC%9D%84%20%EC%B9%98%EB%A9%B4%20%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94%20%EC%9D%BC.md)

2. RESTful API가 무엇인가요? 개념을 설명해주세요. GraphQL에 대해서 알고 있나요? 둘의 차이점에 대해 설명해주세요

A. RESTful API는 REST아키텍쳐 스타일을 따르는 API를 의미합니다. 모든 리소스를 고유한 URI로 식별합니다. Get, POST, PUT, Patch등.. 

GraphQL은 쿼리언어 및 실행환경으로 클라이언트가 서버에 원하는 데이터를 정확히 요청하도록 설계 되었습니다. 하나의 요청으로 여러 리소스를 가져올 수 있습니다. 보통 단일 엔드포인트를 사용합니다. /graphql. 

GraphQL은 효율적인 데이터를 요청할 수 있고, 유연성과 단일 엔드포인트를 가집니다. 