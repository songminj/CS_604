# Chapter 5. 응용 계층
## 05-1 DNS와 자원
### 도메인 네임과 네임 서버
- 도메인 네임: 상대 호스트를 특정하기 위해 IP 주소 대신 사용
- DNS 서버: 도메인 네임 고나리 서버
- 도메인 네이은 점을 기준으로 게층적으로 분류됨
  - 최상단: 루트 도메인: .
  - 다음 단계: 최상위 도메인(TLD) - com, kr, edu, ...
  - 2단계 도메인: second level domain. www.example.com 중 example
  - 3단계 도메인: www.example.com 중 www
  - 전체 주소 도메인 네임(FQDN): www.example.com.
    - FQDN의 첫 번째 부분(www)을 호스트 네임이라 부르기도 함

### 계층적 네임 서버
- 도메인 이름을 통해 IP주소를 알아내는 과정이 필요(= resolving)
- 사용되는 네임 서버
  - 로컬 네임 서버: 클라이언트와 맞닿아 있는 네임 서버. 클라이언트가 도메인 네임을 통해 IP 주소를 알아내고자 할 때 가장 먼저 찾게 되는 네임 서버
    - 일반적으로 ISP에서 로컬 네임 서버의 주소를 할당. 이외에 공개 DNS 서버를 이용할 수도 있음(ex - 8.8.8.8(구글 공개 DNS 서버))
    - 로컬 네임 서버가 대응되는 IP 주소를 모른다면 루트 네임 서버에 해당 도메인 네임을 질의
    - 루트 네임 서버는 질의에 알맞는 TLD 네임 서버의 IP 주소를 제공
  - TLD 네임 서버: TLD를 관리하는 네임 서버. 로컬 네임 서버가 TLD 네임 서버에 질의하면, 알맞은 하위 도메인 네임 서버 주소를 제공
  - 책임 네임 서버: 특정 도메인 영역을 관리하는 네임 서버. 자신이 관리하는 도메인 영역의 질의에 대해 곧바로 답할 수 있는 네임 서버

### DNS 캐시
- 질의 방법
  - 재귀적 질의: 클라이언트가 로컬 네임 서버에 질의하면, 로컬 네임 서버가 루트 네임 서버에 질의, 알맞은 IP 주소 반환
  - 반복적 질의: 클라이언트가 로컬 네임 서버에 질의하면, 로컬 네임 서버가 루트 네임 서버에 질의, 다음 서버의 IP 주소 반환
  - 이 과정은 단계를 많이 거쳐야 하기에 과부하 발생 가능. 이를 해결하기 위해 DNS 캐시 사용
  - TTL이 지나면 캐시 값이 삭제됨

### 자원을 식별하는 URI
- 자원: 네트워크상의 메시지를 통해 주고받는 대상(HTML 파일, 이미지, 동영상 등)
- URI: 자원을 식별할 수 있는 정보
- URL: 위치를 이용해 자원을 식별
  - foo://www.example.com:8042/over/there?name=ferret#nose
  - scheme: 자원에 접근하는 방법. 일반적으로 사용할 프로토콜이 명시됨
  - authority: IP 주소 혹은 도메인 네임
  - path: 자원이 위치한 경로. /를 기준으로 계층적 표현이 되고, 최상위 경로 또한 슬래시로 표현됨
  - query: 검색을 위한 정보
  - fragment: 자원의 한 조각을 가리키기 위한 정보
- URN: 이름을 이용해 자원을 식별

### DNS 레코드 타입
- 네임 서버는 DNS 자원 레코드라 불리는 정보를 저장하고 관리
- 도메인 네임과 IP 주소를 서버에 알리기 위해 직접 작성 가능


## 05-2 HTTP
### HTTP의 특성
  1. 요청과 응답 기반 동작(프로토콜)
  2. 미디어 독립적 프로토콜
     - HTTP 요청 메시지를 통해 서버의 자원을 요청 가능. HTTP는 자원의 특성을 제한하지 않기에 HTML, JPEG, XML 등 다양한 종류의 자원을 주고받을 수 있음
     - 미디어 타입: HTTP에서 메시지로 주고받는 자원의 종류(= MIME 타입)
  3. 무상태
     - 서버가 HTTP 요청을 보낸 클라이언트와 관련된 상태를 기억하지 않음 
     - 여러 클라이언트와 동시에 상호작용하므로 이를 기억하는 것을 비효율적
     - 확장성과 견고성(한 서버에 문제가 생겨도 정상 동작)을 지킬 수 있음
  4. 지속 연결 지원
     - 기본적으로 HTTP는 TCP 기반. 하나의 TCP 연결 상태로 여러 자원을 주고받을 수 있음

### HTTP 메시지 구조
- 시작 라인
  - 요청
    - 메서드: 서버의 자원에 대해 수행할 작업의 종류(GET, POST, PUT, DELETE)
    - 요청 대상: HTTp 요청을 보낼 서버의 자원
    - HTTP 버전: 버전
  - 응답
    - 상태 코드
    - 이유 구문
    - ex) HTTP/1.1 200 OK
- 필드 라인
  - 0개 이상의 HTTP헤더가 명시됨(헤더 라인)
- 메시지 본문

### HTTP 메서드
-   GET: 자원을 습득하기 위한 메서드
-   HEAD: GET과 동일하나, 헤더만을 응답받는 메서드
-   POST: 서버로 하여금 특정 작업을 처리하게끔 하는 메서드
-   PUT: 자원을 대체하기 위한 메서드
-   PATCH: 자원에 대한 부분적 수정을 위한 메서드
-   DELETE: 자원을 삭제하기 위한 메서드
-   CONNECT: 자원에 대한 양방향 연결을 시작하는 메서드
-   OPTIONS: 사용 가능한 메서드 등 통신 옵션을 확인하는 메서드
-   TRACE: 자원에 대한 루프백 테스트를 수행하는 메서드

### HTTP 상태 코드
- 100번대(100~199) 정보성 상태 코드
- 200번대(200~299) 성공 상태 코드
- 300번대(300~399) 리다이렉션 상태 코드
  - 리다이렉션: 요청을 완수하기 위해 추가 조치가 필요한 상태
    - 영구적인 리다이렉션: 자원이 완전히 새로운 곳으로 이동해 경로가 영구적으로 재지정되는 것
    - 일시적인 리다이렉션: 자원의 위치가 임시로 변경된 경우 사용. 여전히 요청을 보낸 URL은 기억해야 함 
- 400번대(400~499) 클라이언트 에러 상태 코드
- 500번대(500~599) 서버 에러 상태 코드

### HTTP 버전
- HTTP/0.9: 거의 사용되지 않는 초창기 HTTP 버전. GET만 사용 가능했음
- HTTP/1.0: HEAD, POST 등 GET 이외의 메서드 도입. 헤더 지원. 지속 연결 지원 X
- HTTP/1.1: 지속 연결 공식 지원 O. 다양한 편의 기능 및 사용 가능한 헤더 추가
- HTTP/2.0: HTTP/1.1의 효율과 성능을 높이기 위한 버전(개선 버전). 헤더를 압축 전송, 바이너리 데이터 기반 메시지를 송수신. 서버 푸시 기능 제공
  - HOL 블로킹(같은 큐에 대기해 순차적으로 처리되는 경우, 앞 패킷의 처리 지연으로 인해 나머지 패킷 처리도 모두 지연되는 문제) 문제를 멀티플렉싱 기법(스트림으로 병렬 처리)으로 완화
- HTTP/3.0: UDP 기반 동작으로 구현된 QUIC 프로토콜을 기반으로 동작. 따라서 더 빠름


## 05-3 HTTP 헤더와 HTTP 기반 기술
### HTTP 헤더
- 요청 시 활용되는 HTTP 헤더
  1. Host: 요청을 보낼 호스트를 나타내는 헤더
  2. User-Agent: 웹 브라우저와 같이 HTTP 요청을 시작하는 클라이언트 측의 프로그램
  3. Referer: 클라이언트가 요청을 보낼 때 머무르고 있던 URL
  4. Authorization: 클라이언트의 인증 정보를 담는 헤더
- 응답 시 활용되는 HTTP 헤더
  1. Server: 요청을 처리하는 서버 측의 SW와 관련된 정보
  2. Allow: 클라이언트에게 허용된 HTTP 메서드 목록을 알려 주기 위해 사용
  3. Retry-After: 응답과 함께 사용될 수 있는 헤더. 자원을 사용할 수 있는 날짜, 시각을 나타냄
  4. Location: 클라이언트에게 자원의 위치를 알려주기 위해 사용되는 헤더
  5. WWW-Authenticate: 자원에 접근하기 위한 인증 방식을 설명하는 헤더
- 요청과 응답 모두에서 활용되는 HTTP 헤더
  1. Date: 메시지 생성 날짜, 시각
  2. Connection: 연결 방식(keep-alive, close)
  3. Content-Length: 본문의 바이트 단위 길이
  4. Content-Type, Content-Language, Content-Encoding: 전송하려는 메시지 본문의  표현 방식을 설명하는 헤더. 표현 헤더

### 캐시
- 응답받은 내용의 사본을 임시로 저장하는 기술. 대역폭 낭비와 응답 지연 방지
  - 개인 정용 캐시: 웹 브라우저에 저장
  - 공용 캐시: 클라이언트와 서버 사이 중간 서버 저장
- 원본이 아닌 사본을 저장. 원본을 저장하지 않으므로 원본이 바뀌었을 때 사본은 그대로임. 이 문제를 해결하기 위해 아래 방법을 사용
  1. 날짜 기반 재검사 
     - 특정 시점 이후 원본에 변경이 있는지 서버에게 질의하고, 답에 따라 대처 
     - 서버는 자원의 변경(200), 유지(304), 삭제(404)에 맞게 상태 코드를 보냄
  2. 엔티티 태그
     - 자원의 버전을 식별
     - 서버는 자원의 변경(200), 유지(304), 삭제(404)에 맞게 상태 코드를 보냄

### 쿠키
- 쿠키: 서버에서 생성되어 클라이언트 측에 저장하는 데이터
- 상태를 유지하지 않는 HTTP 특성을 보완하기 위한 수단
- 쿠키마다 보통 유효 기간이 정해져 있음
- 보안 측면에 대해 한계가 있음
  - 정보가 쉽게 노출되거나 조작될 수 있기 때문
  - 이를 보완하기 위해 Secure와 HttpOnly 속성이 있음
    - Secure: HTTPS 프로토콜이 사용되는 경우에만 쿠키를 전송되도록 하는 속성
    - HttpOnly: HTTP 송수신을 통해서만 쿠키를 이용하도록 제한하는 속성(JS에서 쿠키에 접근하지 못하게 하는 속성)

### 콘텐츠 협상과 표현
- 콘텐츠 협상: 같은 URI에 대해 가장 적합한 자원의 형태를 제공하는 메커니즘